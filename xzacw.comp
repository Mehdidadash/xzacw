component xzacw"Template for user-built kinematics";

description
"""
.if \\n[.g] .mso www.tmac

The xzacw.comp file is a template for creating
kinematics that can be user-built using halcompile.

The unmodified xzacw component can be used
as a kinematics file for a machine with identity
kinematics for an xyz machine employing 3 joints
(motors).

\\fBUSAGE:\\fR

  1) Copy the xzacw.comp file to a user-owned
     directory (\\fBmydir\\fR).

     Note: The xzacw.comp file can be downloaded from:
.URL https://github.com/LinuxCNC/linuxcnc/raw/2.8/src/hal/components/xzacw.comp 
     where '2.8' is the branch name (use 'master' for
     the master branch)

     For a RIP (run-in-place) build, the file is located in
     the git tree as:
       src/hal/components/xzacw.comp

  2) Edit the functions kinematicsForward() and
     kinematicsInverse() as required
  3) If required, add hal pins following examples in
     the template code
  4) Build and install the component using halcompile:
     $ cd \\fBmydir\\fR
     $ [sudo] halcompile --install xzacw.comp
     # Note:
     #      sudo is required when using a deb install
     #      sudo is \\fBnot\\fR required for run-in-place builds
     # $ man halcompile for more info
  5) Specify xzacw in an ini file as:
     \\fB[KINS]\\fR
     \\fBKINEMATICS=xzacw\\fR
     \\fBJOINTS=3\\fR
     # the number of JOINTS must agree with the
     # number of joints used in your modified xzacw.comp
  6) Note: the manpage for xzacw is not updated by
     halcompile --install
  7) To use a different component name, rename the file
     (example mykins.comp) and change all instances of
     'xzacw' to 'mykins'

""";
pin out bit dummy=1; // halcompile requires at least one pin
license "GPL";
;;


static struct haldata {
  hal_u32_t *in;
  hal_u32_t *out;
} *haldata;
// hal pin types:
// hal_bit_t   bit
// hal_u32_t   unsigned 32bit integer
// hal_s32_t   signed 32bit integer
// hal_float_t float (double precision)

static int xzacw_setup(void) {
    int res=0;
    int comp_id;
    // this name must be different than the comp name:
    comp_id = hal_init("xzacwdata");
    if (comp_id < 0) goto error;
    haldata = hal_malloc(sizeof(struct haldata));
    if (!haldata) goto error;

    // hal pin examples:
    res += hal_pin_u32_newf(HAL_IN ,&(haldata->in) ,comp_id,"%s.in" ,"xzacw");
    res += hal_pin_u32_newf(HAL_OUT,&(haldata->out),comp_id,"%s.out","xzacw");

    if (res) goto error;
    hal_ready(comp_id);
    rtapi_print("*** %s setup ok\n",__FILE__);
    return 0;
error:
    rtapi_print("\n!!! %s setup failed res=%d\n\n",__FILE__,res);
    return -1;
}
static hal_u32_t switchkins_type;
#include "kinematics.h"
EXPORT_SYMBOL(kinematicsType);
EXPORT_SYMBOL(kinematicsSwitchable);
EXPORT_SYMBOL(kinematicsSwitch);
EXPORT_SYMBOL(kinematicsInverse);
EXPORT_SYMBOL(kinematicsForward);
int kinematicsSwitchable() {return 0;}
int kinematicsSwitch(int new_switchkins_type)
{
    switchkins_type = new_switchkins_type;
    rtapi_print("kinematicsSwitch(): type=%d\n",switchkins_type);
    // create case structure for switchable kinematics
    
    return 0; // ok
}
KINEMATICS_TYPE kinematicsType()
{
static bool is_setup=0;
    if (!is_setup) xzacw_setup();
    return KINEMATICS_BOTH;
} // kinematicsType()

static bool is_homed=0;
int kinematicsForward(const double *j,
                      EmcPose * pos,
                      const KINEMATICS_FORWARD_FLAGS * fflags,
                      KINEMATICS_INVERSE_FLAGS * iflags)
{
    static bool gave_msg;
    // [KINS]JOINTS=4
    pos->tran.x = j[0]; // X coordinate
    pos->tran.z = j[1]; // Z coordinate
    pos->a = j[2]; // a coordinate
    pos->c = j[3]; // C coordinate
    pos->w = j[4]; // w coordinate
    // unused coordinates:
    pos->tran.y = 0;
    pos->b = 0;
    pos->u = 0;
    pos->v = 0;
    

    if (*haldata->in && !is_homed && !gave_msg) {
       rtapi_print_msg(RTAPI_MSG_ERR,
                       "%s in pin not echoed until homed\n",
                      __FILE__);
       gave_msg=1;
    }
    return 0;
} // kinematicsForward()

int kinematicsInverse(const EmcPose * pos,
                      double *j,
                      const KINEMATICS_INVERSE_FLAGS * iflags,
                      KINEMATICS_FORWARD_FLAGS * fflags)
{
    is_homed = 1; // Inverse is not called until homed

    // Update the kinematic joints specified by the
    // [KINS]JOINTS setting (3 required for this template).
    // Maximum number of joints is defined in include file:
    //         emcmotcfg:EMCMOT_MAX_JOINTS (typ 9)
    j[0] = pos->tran.x; // joint 0
    j[1] = pos->tran.z; // joint 1
    j[2] = pos->a; // joint 2
    j[3] = pos->c; // joint 3
    j[4] = pos->w; // joint 4

    //example hal pin update (homing reqd before kinematicsInverse)
    *haldata->out = *haldata->in;

    return 0;
} // kinematicsInverse()